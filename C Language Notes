---
title: C语言学习笔记
---

# C语言笔记
@(C language)

- **1.输入a和b两个整数,按先大后小的顺序输出a和b**

**方法一：**利用改变指针变量的值来实现（即改变指针的指向）
```C
#include <stdio.h>
#include <stdlib.h>

/*
输入a和b两个整数，按先大后小的顺序输出a和b; 
方法一：利用改变指针变量的值来实现（即改变指针的指向） 
*/ 

int main() {
	int *p1,*p2,a,b;
	int *temp;
	printf("Please enter two numbers:");
	scanf("%d %d",&a,&b);//注意在运行时，输入数据的格式要和scanf中的格式相同； 
	p1=&a;
	p2=&b;
	if(a<b)
	{
		temp=p1;
		p1=p2;
		p2=temp;
	}
	printf("Max=%d,Min=%d",*p1,*p2);
	return 0;
}
```
**方法二：**利用交换指针变量指向的变量值（即交换a和b的值） 
```C
#include <stdio.h>
#include <stdlib.h>

/*
方法二：利用交换指针变量指向的变量值（即交换a和b的值） 
*/
int main(){
	int *p1,*p2,a,b;
	int temp;
	printf("Please enter two numbers:");
	scanf("%d,%d",&a,&b);
	p1=&a;
	p2=&b;
	if(a>b)
	{
		// *p1和*p2实际就是表示指针变量p1和 p2指向的变量（即a 和 b） 
		temp=*p1;
		*p1=*p2;
		*p2=temp;	
	} 
	printf("%d %d",a,b);
	return 0;
}
```
**方法三：**使用函数处理，将指向两个整型变量的指针变量作为实参传递给swap函数的形参指针变量，在函数中通过指针变量实现交换两个变量的值。

**注：**
（1）在函数调用时，将实参变量的值传递给形参变量，采取的依然是**单向**传送的“值传递”方式。（实参--->形参）
（2）**不能企图通过改变指针形参的值而改变指针实参的值 。**因为 C语言中实参变量和形参变量之间的数据传递是单向的"值传递"方式。用指针变量作为函数参数依然要遵循这一规则。 
（3）不可能通过执行调用函数来改变实参指针变量的值，**但是可以改变实参指针变量所指向变量的值 **

**（1）**下面这段代码就是*试图通过实参变量的值传入形参变量，然后再改变形参变量的值，然后**又传回到实参变量。这显然是无法实现的** *
```C
int main(){
	void swap(int *p1,int *p2);
	int *pointer_1,*pointer_2,a,b;
	printf("Please enter two numbers:");
	scanf("%d,%d",&a,&b);
	pointer_1=&a;
	pointer_2=&b;
	if(a>b)
	{
		swap(pointer_1,pointer_2);
	}
	printf("%d %d",*pointer_1,*pointer_2);
	return 0;
} 
void swap(int *p1,int *p2)
{
	//交换形参指针变量的值
	int *temp;
	temp=p1;
	p1=p2;
	p2=temp;
}
```
结果并不能实现a和b的值交换，因为改变形参指针变量p1和p2的值并不能改变实参指针变量pointer_1和pointer_2的值。
**（2）**通过执行调用函数来改变实参指针变量**所指向变量的值**。（可以实现两个输入的整数按从小到大的顺序输出）
```C
/*
方法三：通过执行调用函数来改变实参指针变量所指向变量的值，从而实现a和b的值交换*/ 
int main(){
	void swap(int *p1,int *p2);
	int *pointer_1,*pointer_2,a,b;
	printf("Please enter two numbers:");
	scanf("%d,%d",&a,&b);
	pointer_1=&a;
	pointer_2=&b;
	if(a>b)
	{
		swap(pointer_1,pointer_2);
	}
	printf("%d %d",*pointer_1,*pointer_2);//通过执行调用函数可以实现改变实参指针变量所指向变量的值。 
//	printf("%d %d",a,b);  //两种输出效果一样，因为*pointer_1和a是一个意思 
	return 0;
} 
void swap(int *p1,int *p2)
{
	int temp;
	temp=*p1;
	*p1=*p2;
	*p2=temp;
}

```
**注：**
**函数的调用可以（且只可以）得到一个返回值（即函数值），而使用指针变量作参数，可以得到多个变化了的值。**

**拓展：**
输入3个整数a,b,c, 要求按照从小到大的顺序将它们输出，用函数实现。
```C
#include <stdio.h>
#include <stdlib.h>

/* 
输入3个整数a,b,c,要求按照从小到大的顺序输出，利用函数的形式 
 */

int main() {
	void exchange(int *p1,int *p2,int *p3);
	int *pointer_1,*pointer_2,*pointer_3,a,b,c;
	printf("Please enter three numbers:");
	scanf("%d %d %d",&a,&b,&c);
	pointer_1=&a;
	pointer_2=&b;
	pointer_3=&c;
	printf("%d\n",pointer_1); 
	exchange(pointer_1,pointer_2,pointer_3);  //注意：exchange函数中的参数都是指针变量 
	printf("%d %d %d\n",*pointer_1,*pointer_2,*pointer_3); 
	printf("%d\n",pointer_1); //可以发现实参指针变量在执行完调用函数后依然没有改变 
	return 0;
}

void exchange(int *p1,int *p2,int *p3)
{
	void swap(int *p_1,int *p_2);
	if(*p1>*p2)
		swap(p1,p2);  //swap函数中的参数是指针变量，但其中交换的是指针变量指向的变量的值 
	if(*p2>*p3)
		swap(p2,p3);
	if(*p1>*p3)
		swap(p1,p3);
}

void swap(int *p_1,int *p_2)
{
	int temp;
	temp=*p_1;
	*p_1=*p_2;
	*p_2=temp;
}
```
**注意：**
main函数中的3个实参指针变量的值在执行完调用函数并未改变，这就正好说明前面所说的**“执行完调用函数，并不能改变实参指针变量的值，但是可以改变实参指针变量指向的变量的值”**

- **2. 如何遍历数组中的全部元素**
引用一个数组元素主要有以下两种方法：
（1）下标法：如 a[i];
（2）指针法：

  | 格 式 | 具体说明|
  |:------:|:---------:|
  |\*(a+i)|a是数组名，通过数组名和元素序号计算元素地址，从而找到该元素|
  |\*(p+i)|p是指向数组元素的指针变量，其初值为p=a|

  **注：**
  (1)其实上面两者与a[i]是等价的;
  (2)*(a+i)即使按数组首元素的地址加上相对位移量得到要找的元素的地址，然后找出该地址的内容。
  相对位移量=i * 基本类型的字节长度；（如int类型一般就是4个字节，而char型一般就是1个字节）
  
  
输出一个拥有10个元素的整形数组的全部元素。 

方法 一：利用数组下标的方式访问数组元素 
```C
int main() {
	int a[10];
	int i,j,length;
	length=sizeof(a)/sizeof(int); //求出数组的长度 
	for(i=0;i<length;i++)
	{
		scanf("%d",&a[i]);
	} 
	for(j=0;j<length;j++)
	{
		printf("%d\n",a[j]);
	}
	return 0;
}
```
方法二：通过计算数组名计算数组元素地址，从而找出元素的值。
```C
int main()
{
	int a[10];
	int i,length;
	length=sizeof(a)/sizeof(int);
	for(i=0;i<length;i++)
	{
		scanf("%d",&a[i]);
	}
	for(i=0;i<length;i++)
	{
		printf("%d\t",*(a+i)); //通过数组名和元素序号计算元素地址，再找到该元素。 
	}
	return 0;
 } 
*/ 
```

方法三：利用指针变量指向数组元素的方式访问数组元素 （这样不必每次都重新计算地址）
```C
int main()
{
	int a[10];
	int *p;
	//p=a;   //与p=&a[0]等价
	for(p=a;p<(a+10);p++)
	{
		scanf("%d",p);
	} 
	
	for(p=a;p<(a+10);p++)
	{
		printf("%d\t",*p);
	}
	return 0;
 } 
```
注意一个易错点：
```C
int main()
{
	int a[10];
	int i,length,*p;
	length=sizeof(a)/sizeof(int);
	p=a;
	for(i=0;i<length;i++)
	{
		scanf("%d",p++);
	}
	p=a; //注意：这里一定要重新将 &a[0]的初始值赋给p,不然此时的p在下一个for循环的初始值就为 &a[10]了。 
	for(i=0;i<length;i++,p++)
	{
		printf("%d\t",*p); //通过数组名和元素序号计算元素地址，再找到该元素。 
	}
	return 0;
 } 
```
上面的第二个for循环也可以稍作修改，效果完全一样
```C
	for(i=0;i<length;i++)  //注意修改的部分 
	{
		printf("%d\t",*p++); //通过数组名和元素序号计算元素地址，再找到该元素。 
	}
	return 0;
```
- **3. 通过指针引用数组元素的一些注意事项**
**（1）** **指向数组的指针变量也可以带下标**，如p[i],.因为在程序编译时，对下标的处理方法是转换为地址的，**对p[i]处理成*(p+i)**,因此**如果**p是指向一个整型数组元素a[0]，则p[i]代表a[i].
**（2） \*p++ **   （注意理解）
由于++和\*同优先级，且结合方向为**自右向左**，因此它等价于**\*(p++)**。**先引用p的值，实现*p的运算，然后再使p自增1。**
```C
*p++相当于*(p++),也就是下面两步的组合：
第一步：*p
第二步：p++
//先取*p,再使p值加1；
```
```C
*(++p)则是下面两步的组合：
第一步：p++
第二步：*p
//先使p值加1，再取*p；
```
```C
++(*p)则表示p所指向的元素值加1，如果p=a,则++(*p)相当于++a[0].
```
**（3）如果p当前指向a数组中第i个元素a[i],则下列表达形式一一对应：**

|第一种表达方式|对应的第二种表达方式|
|:-------:|:---------:|
|*(p- -)|a[i++]|
|*(++p)|a[++i]|
|*(- -p)|a[- -i]|

- **4. 用数组名作函数参数和用变量名作函数参数**

**(1)**当用**数组名作函数参数**时，如果形参数组中各元素的值发生变化，则**实参数组元素的值**也随之发生**变化**。（常使用这种方法改变实参数组的值）
实参数组名代表数组首元素的地址，而形参是用来接收来自实参传递过来的数组首元素地址的。因此，形参应该是一个指针变量（只有指针变量才能存放地址）。实际上，C编译都是将形参数组名作为指针变量来处理的。

例：
函数fun的参数写成数组形式
```C
fun(int arr[],int n) 
//arr为形参数组名
```
但程序在编译时是将形参数组名arr按指针变量处理的，相当于将fun的首部写成
```C
fun(int *arr,int n)
```
这两种写法完全等价。
**（2）**以变量名和数组名作为函数参数的比较

|实参类型|变量名|数组名|
|:----------:|:----:|:----------: |
|要求形参的类型|变量名|数组名或指针变量|
|传递的信息|变量的值|实参数组首元素的地址|
|通过函数调用能否改变实参的值|不能**实参变量**的值|**能**改变**实参数组**的值|

**注：**
**实参数组名**代表一个**固定的地址**，或者说是**指针常量**，但**形参数组名**并不是一个固定的地址，而是按**指针变量**处理。
**（3）**用数组名作函数参数
```C
/*
将数组a中n个整数按相反顺序存放。 (两头的元素相互交换)
*/
int main() {
	void inv(int *arr,int n);
	int a[10]={1,5,6,9,7,8,3,2,0,4};
	int i,length;
	length=sizeof(a)/sizeof(int);
	printf("The original order is:\n");
	for(i=0;i<length;i++)
	{
		printf("%d\t",a[i]);
	}
	inv(a,length);//两头交换顺序 
	printf("\n");
	printf("The new order is:\n");
	for(i=0;i<length;i++)
	{
		printf("%d\t",a[i]);
	}
	return 0;
}

void inv(int arr[],int n) //写成int *arr也可以 
{
	int i=0,j,temp;
	int flag=n/2;
	while(i<flag)
	{
		j=n-i-1;
		temp=arr[i];
		arr[i]=arr[j];
		arr[j]=temp;
		i++;	
	}
	return; 
}
```
**（4）**用指针变量作函数参数
```C
int main()
{
	void inv(int *arr,int n);
	int a[10]={1,5,6,9,7,8,3,2,0,4};
	int i,length;
	length=sizeof(a)/sizeof(int);
	printf("The original order is:\n");
	for(i=0;i<length;i++)
	{
		printf("%d\t",a[i]);
	}
	inv(a,length);//两头交换顺序 
	printf("\n");
	printf("The new order is:\n");
	for(i=0;i<length;i++)
	{
		printf("%d\t",a[i]);
	}
	return 0;
}
//改进之后
void inv(int *arr,int n)
{
	int *i,*j,*p,temp;
	int flag=n/2;
	i=arr;
	j=arr+n-1;
	p=arr+flag;
	for(;i<p;i++,j--)
	{
		temp=*i;
		*i=*j;
		*j=temp;
	}
	return;
 } 
```
**（5）**如果用**指针变量作实参**，必须**先使指针变量有一个确定值**，指向一个已定义的对象。
如下面是不正确的：
```C
int main()
{
	void f(int *x,int n);
	int *p;//指针变量未指向数组元素（或者说一个已定义的对象）。
	...
	f(p,10);
	...
}

void f(int *x,int n)
{
    ...
	return;
}
```
编译时出错，原因是指针变量p没有确定值，谈不上指向哪个变量。

- **5. 使用指针引用多维数组**

**（1）**二维数组a的有关指针

|表示形式|含义|地址|
|:------:|:----:|:--------:|
|a|二维数组名，指向一维数组a[0],即0行首地址|2000|
|a[0],\*(a+0),\*a|0行0列元素地址|2000|
|a+1,&a[1]|1行首地址|2016|
|a\[1\],*(a+1)|1行0列的地址，即&a[1]\[0\]|2016|
|a\[1\]+2,\*(a+1)+2,&a[1]\[2\]|1行2列元素地址,即&a\[1\]\[2\]|2024|
|\*(a\[1\]+2),\*(*(a+1)+2),a[1]\[2\]|1行2列元素的值，即a\[1\]\[2\]|元素值为13|

**注：**
(1) 二维数组a的定义如下：
```C
int a[3][4]={{1,3,5,7},{9,11,13,15},{17,19,21,23}}
```
且假设二维数组a的首行的首地址为2000.
(2) C语言规定了数组名代表数组首元素的地址。所以
a为二维数组名，指向一维数组a[0]（二维数组的首元素），即0行首地址；
a\[0\]为一维数组名，指向一维数组的首元素即a\[0\]\[0\]，即0行0列元素地址；
(3) a+1是二维数组a中序号为1的行的首地址（序号从0算起），即1行首地址，因为a是二维数组名，指向一维数组a[0]，表示0行首地址。**千万不要和a[0]+1搞混，**a[0]+1表示0行1列元素的地址。
(4) \*(a+1)表示1行0列元素地址，即&a\[1\]\[0\]，和a[1]等价。

(5) **二维数组名**（如a）是指向**行**的。因此a+1中的‘1’代表一行中全部元素所占的字节数（一行有4个整形元素，所以占16个字节）。**一维数组名**（如a[0],a[1]）是指向**列元素**的。因此a[0]+1中的‘1’代表一个元素所占的字节数（一个整形元素，所以占4个字节）。
(6) 在**指向行的指针**前面加一个\*号，就转换为**指向列的指针**。
(7) 在**指向列的指针**前面加一个&号，就转换为**指向行的指针**。
(8) a[0]指向0行0列元素的指针，&a[0]则指向二维数组的0行，与a等价。因为a[0]与*(a+0)等价，因此&a[0]与&\*a等价，也就是与a等价，它指向二维数组的0行。
(9) &a[i]和a[i]的值虽然一样，但它们的含义不一样。**&a[i]**或**a+i**指向**行**，而**a[i]**或**\*(a+i)**指向**列**。

- **6. 指向多维数组元素的指针变量**
**(1)**指向**数组元素**的指针变量
```C
/*
指向多维数组元素的指针变量
	(1)指向数组元素的指针变量 
 */
//用指向元素的指针变量输出二维数组各元素的值。 
int main() {
	int a[3][4]={1,3,5,7,9,11,13,15,17,19,21,23};
	int *p;
	for(p=a[0];p<a[0]+12;p++)  //注意：p是指向整形元素的，如这里p初始指向a[0][0]; 
	{
		if((p-a[0])%4==0) //p移动4次后换行 
		{
			printf("\n");	
		}
		
		//(1) %4d表示输出的整形数据宽度为4位，且右对齐，如果整形数据不够4位则前面补空格;
		//(2) 如果要左对齐，则在%后加"-"号即可，如"%-4d" ;
		
		printf("%-4d",*p); 
	}
	return 0;
}
```
**(2)**指向由m个元素组成的**一维数组**的指针变量
```C
/*
指向m个元素组成的一维数组的指针变量 
*/
int main()
{
	int a[3][4]={1,3,5,7,9,11,13,15,17,19,21,23};
	int (*p)[4],i,j;
	p=a;   // p的值是一维数组a[0]的起始地址;
	printf("Please enter row and column:\t");
	scanf("%d,%d",&i,&j);
	printf("a[%d,%d]=%d\n",i,j,*(*(p+i)+j));
	return 0;	
} 
```
**注：**
（1）int (*p)[4]表示定义p为一个指针变量，它指向包含4个整形元素的一维数组。 
（2）\*p两侧的括号不可以缺少， 若写成\*p[4]则表示指针数组。（因为方括号[ ]的运算优先级别高）
（3）

|格式|含义|
|:-----:|:------:|
| int a[4]|a有4个元素，每个元素都是整型|
|int (\*p)[4]|\*p有4个元素，每个元素为整型。也即p所指的对象是有4个整型元素的数组，即p是指向一维数组的指针。|

（4）int (\*p)[4]中的**p**的类型不是int *类型，而是int (\*)[4]型，p被定义为指向一维整形数组的指针变量，一维数组有4个元素，因此p的基类型为一维数组，其长度是16字节。
**（3）**一个需要注意的地方
```C
int main()
{
	int a[4]={1,3,5,7}; //这里是一维数组
	int (*p)[4];
	//不能写成 p=a,因为这样写表示p的值是&a[0],指向a[0],一维数组名表示首元素的地址; 
	p=&a;  //表示p指向一维数组（行） 
	printf("%d\n",(*p)[2]);//表示访问p所指向一维数组（行）中的序号为2的元素; 
	return 0;
}
```
- **7. 引用一个字符串的方法**

**(1)** 用**字符数组**存放一个字符串，可以通过**数组名和下标**引用字符串中一个字符，也可通过**数组名和格式声明"%s"**输出该字符串。
```C
char string[]="I love China!";
printf("%s\n",string);//用%s格式声明输出string,可以输出整个字符串。
printf("%c\n",string[3]);//使用%c格式输出一个字符数组元素。
```
**(2)**用**字符指针变量**指向一个**字符串常量**，通过字符指针变量引用字符串常量。
```C
//指针变量string指向字符串的第1个字符
char *string="I love China!";//定义指针变量并初始化。
printf("%s\n",string);
```
**注：**
（1）C语言中只有字符变量，**没有字符串变量**。
（2）这两者是等价的
```C
char *string="I am a student";
```
```C
char *string;
string="I am a student";
```
上述语句都是将字符串的第一个字符的地址赋给指针变量string，此后string就指向“I am a student”.
当然也可以对string重新赋值，从而改变string的指向。
（3）%s是输出字符串时所用的格式符，在输出项中给出字符指针变量名string，则系统会输出string所指向的第一个字符，**然后自动使string加1**，使之指向下一个字符，再输出该字符......如此直到遇到字符串结束标志'\0'为止。

- **8.复制一个字符数组到另外一个字符数组（字符串间的复制）—— 一种效果的多种实现方式**

```C
int main()
{
	void copy_string(char *a,char *b);
	char a[]="I am a teacher.";
	char b[]="You are a student.";
	int i;
	printf("String a is: %s\n",a);
	printf("String b is: %s\n",b);
	printf("copy string a to string b:\n");
	copy_string(a,b);
	printf("String a is: %s\n",a);
	printf("String b is: %s\n",b);
	return 0;
} 

void copy_string(char *a,char *b)
{
	for(;*b++=*a++;); 
} 
```
**上述copy_string函数中可以有多种不同方式而实现相同的效果。 **

**(1)**
```C
while(*a!='\0')
{
	*b++=*a++;
}
*b='\0';
```	
**(2)**
```C
while((*b=*a)!='\0')
{
	b++;
	a++;
} 
```
**(3)**
```C
while((*b++=*a++)!='\0');
```
**(4)**
```C
 //注意"\0"的ASCII码为0; 
 while((*b++=*a++)!=0);//千万不要忘了加";"  
```
也可以写成
```C
 while(*b++=*a++);
``` 
**注：**不等于0也就是表示为真, 这里表示先把*a的值赋值给*b,再判断*b是否为0（'\0'的ASCII值为0），为0则跳出while循环，否则继续将a数组中的未复制的字符复制到b数组中去。 
**(5)**
```C
for(;*b++=*a++;); 
```
 或
```C
for(;(*b++=*a++)!=0;); 
```

- **9. 用字符指针作为函数参数时，实参与形参的类型的对应关系有如下几种：**

|实参|形参|
|:--:|:--:|
|字符数组名|字符数组名|
|字符数组名|字符指针变量|
|字符指针变量|字符指针变量|
|字符指针变量|字符数组名|

- **10. 字符指针变量和字符数组的比较（七个小点）**

**（1）**字符数组由若干个元素组成，每个元素中放一个字符。而字符指针变量中存放的是地址（字符串中第一个字符的地址）。
**（2）赋值方式：**可以对字符指针变量赋值，但不能对数组名赋值。
```C
char *a;//定义a为字符指针变量
a="I love China!";//将字符串首元素的地址赋给指针变量。合法。
```
```C
char str[14];
str[0]='I';//对字符数组元素赋值，合法。
str="I love China!";//数组名是地址，是常量，不能被赋值，非法。
```
**（3）**初始化

**字符指针变量的赋值**
```C
char *a="I love China!";//定义并赋值。
```
等价于
```C
char *a;//先定义
a="I love China!"; //再赋值
```
**数组的初始化**
```C
char str[14]="I love China!";//定义字符数组str，并把字符串赋给数组中各元素。合法。
```
**不**等价于（下面这种字符数组的初始化是**非法的**）
```C
char str[14];
str[]="I love China!";//企图把字符串赋给数组中各元素。错误。
```
**注：**
**数组可以在定义时对各元素赋初值，但不能用赋值语句对字符数组中全部元素整体赋值。**
**（4）**存储单元的内容。编译时**字符数组**分配**若干存储单元**，以存放各元素的值；而对**字符指针变量**，只分配**一个存储单元**（Visual C++为指针变量分配4个字节）。
**（5）**如果定义了**字符数组**，但未对它赋值，这时数组中的元素的值是**不可预料的**。可以引用（如输出）这些值，结果显然是**无意义的**，但不会造成严重的后果，容易发现和改正。
如果定义**字符指针变量**，应当及时把一个字符变量（或字符数组元素）的地址赋值给它，使它指向一个字符型数据，如果未对它赋予一个地址值，它并未具体指向一个确定的对象。此时如果向该指针变量所指向的对象输入数据，**可能**会造成**严重的后果**。（**定义了字符指针变量应及时赋值**）
```C
char *a;//定义字符指针变量a
scanf("%s",a);//企图从键盘输入一个字符串，使a指向该字符串。错误。
```
**注意：**此时a的值是不可预料的，它可能指向内存中空白的（未用的）用户存储区（好的情况），也有可能指向内存中已存储指令或数据的有用内存段，这就会破坏程序或有用数据，甚至破坏了系统，会造成严重的结果。
因此在定义指针变量后，及时指定其指向，如：
```C
char *a,str[10];
a=str;//使a指向str数组的首元素
scanf("%s",a);//从键盘输入一个字符串存放到a所指向的一段存储单元中。正确。
```
**（5）** **指针变量的值**是**可改变的**；而**数组名**代表一个**固定的值**（数组元素的地址），是**不可改变的**。

改变指针变量的值
```C
char *a="I love China!";
a=a+7;//改变指针变量的值，使a指向字符串中的第7个字符。
printf("%s",a);//输出的结果为“China！”
```
下面是错误的
```C
char str[]={"I love China!"};
str=str+7;//错误
printf("%s",str);
```
**（6）** **字符数组**中**各元素的值**是可以改变的（**可以**对它们**再赋值**）；但**字符指针变量指向的字符串常量中的内容**是不可以被取代的（**不能**对它们**再赋值**）。
```C
char a[]="House";
char *b="House";
a[2]='r';//合法，r取代a数组元素a[2]的原值u.
b[2]='r';//非法。字符串常量不能改变。
```
**（7）**用指针变量指向一个格式字符串，可以用它代替printf函数中的格式字符串。
```C
char *format;
format="a=%d,b=%f\n";//使format指向一个字符串。
printf(format,a,b);//这种printf函数称为可变格式输出函数。
```
